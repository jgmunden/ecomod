
# Using Rcpp/C++ build correct row, col indices and associated operations for state space and propensity calculations

require(Rcpp)

sourceCpp( rebuild=TRUE, code='
#include <Rcpp.h>
#include<string>
#include<iostream>
#include<algorithm>

using namespace Rcpp;



// [[Rcpp::export]]
bool is_zero (int y) {
  return(y==0);
}



// [[Rcpp::plugins("cpp11")]]  
// [[Rcpp::export]]
List reaction_location_indices ( std::vector<int> J, std::vector<int> NU, int nr, int nc ) {

  // remap random element to correct location and process

  List out ;
  
  int j0, jj, cr, cc, jn, oi, op, w, v, k ;
  int ro, co ;  // # row and col can turn negative (temporarily)

  int nrc = nr * nc;
  
  int nc0 = 2 ;  // # boundaries using R-indices 
  int nc1 = nc-1 ; 
  int nr0 = 2 ;
  int nr1 = nr-1 ;
  
  int nt = J.size() ;
  int plen = 6 ; // number of elements in NU for each process 3 (r,c,oper) X 2 (focal, neighbour) 
  
  std::vector<int> ixrow, ixcol, ixdelete, ixoper ;
  std::vector<std::string> ixrc;
  std::string rcid ; 

  for ( w = 0 ; w < nt ; ++w ) {
      
      // focal cell coords in P
      j0 =  J[w] -1 ;  // -1 as R indices begin at 1 (J) while C starts at 0
      jn =  j0 / nrc ;         // -- processes np
      jj =  j0 - jn*nrc ;
      cc =  jj / nr ;       //    -- col no
      cr =  jj - cc*nr ;        //    -- row no 

      for ( v = 0; v < 2; ++v ) {
          oi = jn * plen + v*3 ;  // starting index of operations from jn
          // determine new operations and candidate locations 
          op = NU[oi+2] ;  // # 1st operation
          if (op==0) continue ;  // # unary reaction  this is a placeholde that can be skipped
          ro = cr + NU[oi]   + 1; // # row of the focal cell  ; +1 to have R-indices 
          co = cc + NU[oi+1] + 1; // # column of the focal cell

          //# ensure boundary conditions are sane (reflective boundary conditions, these are now R-indices)
          if (ro < 1) ro=nr0 ;
          if (ro >= nr) ro=nr1 ;
          if (co < 1) co= nc0 ;
          if (co >= nc) co = nc1 ; 
          
          // add operations to output indices
          ixrow.push_back(ro) ;   
          ixcol.push_back(co) ;
          ixoper.push_back(op) ;
          rcid = std::to_string(ro) + std::to_string(co);
          ixrc.push_back( rcid ) ; 
      } 
  }
 
  // id duplicated locations but keep/tabulate operations 
  k = ixoper.size() ;
  for ( w =0; w < k ; ++w ) {
    for ( v=w+1; v < k; ++ v ){  
      if ( ixrc[w] == ixrc[v] ) {
        ixoper[w] += ixoper[v] ;
        ixoper[v] = 0 ; // set to zero to flag for deletion
      }
    }
  }

  for ( w =0; w < k ; ++w ) {
    if ( ixoper[w] == 0 ) {
       ixcol[w] = 0 ; // as above  .. R-indices start at 1 so 0 => flag for delete
       ixrow[w] = 0 ; // as above
    }
  }

  ixoper.erase( remove_if( ixoper.begin(), ixoper.end(), is_zero), ixoper.end() ) ;
  ixrow.erase( remove_if( ixrow.begin(), ixrow.end(), is_zero), ixrow.end() ) ;
  ixcol.erase( remove_if( ixcol.begin(), ixcol.end(), is_zero), ixcol.end() ) ;


  // ix complete, now create ip (iprow, ipcol, ipreactionchanel )
  
  int np = NU.size() / plen ;
  int nix = ixoper.size() ;
  int nip = nix * np  ; 
  std::vector<int> iprow (nip), ipcol(nip), ipreac(nip) ; 
  int m;

  for ( v=0; v<np ; ++v ) {
    for ( w=0; w< nix; ++w) {
      m = w + v*nix ;
      iprow[m] = ixrow[w] ;
      ipcol[m] = ixcol[w] ;
      ipreac[m] = v+1 ; 
    }
  }

  out["xr"] = ixrow   ;
  out["xc"] = ixcol   ;
  out["xo"] = ixoper   ;
 
  out["pr"] = iprow   ;
  out["pc"] = ipcol   ;
  out["po"] = ipreac  ;
  
  return( out );
}')




