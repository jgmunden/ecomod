
require(Rcpp)

sourceCpp( rebuild=TRUE, code='
#include <RcppArmadillo.h>
// [[Rcpp::export]]
// [[Rcpp::depends(RcppArmadillo)]]

using namespace Rcpp;

List reaction_index ( std::vector<unsigned int> J, Rcpp::NumericMatrix NU, unsigned int nr, unsigned int nc, unsigned int np ) {

  // remap random element to correct location and process
  
  unsigned int foc, cr, cc, jn, no ;
  
  NumericVector o;

  unsigned int oc = 3 ; // number of colums in o or NU
  unsigned int nrc = nr * nc;
  unsigned int nc0 = 1 ;  // 1 less than R-version due to indices starting at 0
  unsigned int nc1 = nc-2 ; // 1 less than R-version due to indices starting at 0
  unsigned int nr0 = 1 ;
  unsigned int nr1 = nr-2 ;
  
  unsigned int nt = J.size() ;
  unsigned int nip = np * nt ;  // number of propensity locations 
  
  std::vector<unsigned int> ix (nix)  ;
  std::vector<unsigned int> ip (nip)  ;
  
  List out ; // output list

  for ( int w = 0 ; w < nt ; ++w ) {
      
      // focal cell coords in P
      foc = J[w] ;
      cr =  foc % nr;           //    -- row no
      cc = (foc/nr) % nc;       //    -- col no
      jn =  foc / nrc ;         // -- processes np

      o = NU( _, _, jn ) ;  // Rcpp sugar usage
      no = o.size() / oc ;

      for ( m=0; m<no; ++m) {
          // determine new candidate locations 
          ro = cr + o( m*3  );  // # row of the focal cell
          co = cc + o( m*3 + 2 ) ; // # column of the focal cell
          //# ensure boundary conditions are sane (reflective boundary conditions)
          if (ro < 0) ro=nr0 ;
          if (ro >= nr) ro=nr1 ;
          if (co < 0) co= nc0 ;
          if (co >= nc) co = nc1 ; 
          // X-indices
          ix = ro + (co * nr);     
          // update all P-indices
          for ( jj=0; jj < np; ++jj ) {
            ip = ro + (co * nr) + jj * nrc ;           
          }
      } 
  } 
  
  out["ix"] = ix ;
  out["ip"] = ip ;
  
  return( out );
}')


